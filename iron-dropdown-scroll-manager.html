<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">

<script>
  (function() {
    'use strict';
    // Used to calculate the scroll direction.
    var lastTouch = null;

    /**
     * The IronDropdownScrollManager is intended to provide a central source
     * of authority and control over which elements in a document are currently
     * allowed to scroll.
     */

    Polymer.IronDropdownScrollManager = {

      /**
       * The current element that defines the DOM boundaries of the
       * scroll lock. This is always the most recently locking element.
       */
      get currentLockingElement() {
        return this._lockingElements[this._lockingElements.length - 1];
      },


      /**
       * Returns true if the element causing the scroll is "scroll locked," which is to
       * say that it cannot be scrolled via pointer or keyboard interactions, or
       * if already at its scroll boundaries.
       *
       * @param {Event} event The scroll event
       */
      shouldPreventScrolling: function(event) {
        // Avoid expensive checks if the event is not one of the observed keys.
        if (event.type === 'keydown' && !this._isScrollingKeypress(event)) {
          return false;
        }

        var currentLockingElement = this.currentLockingElement;
        if (currentLockingElement === undefined) {
          return false;
        }

        var xDelta = event.wheelDeltaX;
        var yDelta = event.wheelDeltaY;
        if (event.type === 'touchmove' && lastTouch) {
          xDelta = lastTouch.pageX - event.pageX;
          yDelta = event.pageY - lastTouch.pageY;
        }

        var nodes = Polymer.dom(event).path;
        var lockingIndex = nodes.indexOf(currentLockingElement);
        // Search for one scrollable that can still scroll, stop at the locked element.
        for (var i = 0; i < lockingIndex; i++) {
          var node = nodes[i];

          // Check either vertical or horizontal, according to where
          // there was more scroll.
          var scrollDelta, scrollableSize, scrollPos;
          if (Math.abs(yDelta) >= Math.abs(xDelta)) {
            scrollDelta = yDelta;
            scrollableSize = node.scrollHeight - node.clientHeight;
            scrollPos = node.scrollTop;
          } else {
            scrollDelta = xDelta;
            scrollableSize = node.scrollWidth - node.clientWidth;
            scrollPos = node.scrollLeft;
          }
          // If it can scroll, don't prevent.
          if (scrollDelta !== 0 && scrollableSize > 0 &&
              (scrollDelta > 0 ? scrollPos > 0 : scrollPos < scrollableSize)) {
            return false;
          }
        }
        // Don't prevent if event's target is currentLockingElement.
        return lockingIndex !== 0;
      },

      /**
       * Push an element onto the current scroll lock stack. The most recently
       * pushed element and its children will be considered scrollable. All
       * other elements will not be scrollable.
       *
       * Scroll locking is implemented as a stack so that cases such as
       * dropdowns within dropdowns are handled well.
       *
       * @param {HTMLElement} element The element that should lock scroll.
       */
      pushScrollLock: function(element) {
        // Prevent pushing the same element twice
        if (this._lockingElements.indexOf(element) >= 0) {
          return;
        }

        if (this._lockingElements.length === 0) {
          this._lockScrollInteractions();
        }

        this._lockingElements.push(element);
      },

      /**
       * Remove an element from the scroll lock stack. The element being
       * removed does not need to be the most recently pushed element. However,
       * the scroll lock constraints only change when the most recently pushed
       * element is removed.
       *
       * @param {HTMLElement} element The element to remove from the scroll
       * lock stack.
       */
      removeScrollLock: function(element) {
        var index = this._lockingElements.indexOf(element);

        if (index === -1) {
          return;
        }

        this._lockingElements.splice(index, 1);

        if (this._lockingElements.length === 0) {
          this._unlockScrollInteractions();
        }
      },

      _lockingElements: [],

      _originalBodyStyles: {},

      _isScrollingKeypress: function(event) {
        return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(
          event, 'pageup pagedown home end up left down right');
      },

      _scrollInteractionHandler: function(event) {
        if (Polymer.IronDropdownScrollManager.shouldPreventScrolling(event)) {
          event.preventDefault();
        }
        lastTouch = event;
      },

      _lockScrollInteractions: function() {
        // Memoize body scroll position
        this._saveScrollPosition();
        document.addEventListener('scroll', this._restoreScrollPosition, true);

        // Modern `wheel` event for mouse wheel scrolling:
        document.addEventListener('wheel', this._scrollInteractionHandler, true);
        // Older, non-standard `mousewheel` event for some FF:
        document.addEventListener('mousewheel', this._scrollInteractionHandler, true);
        // IE:
        document.addEventListener('DOMMouseScroll', this._scrollInteractionHandler, true);
        // Mobile devices can scroll on touch move:
        document.addEventListener('touchmove', this._scrollInteractionHandler, true);
        // Capture keydown to prevent scrolling keys (pageup, pagedown etc.)
        document.addEventListener('keydown', this._scrollInteractionHandler, true);
      },

      _unlockScrollInteractions: function() {
        document.removeEventListener('scroll', this._restoreScrollPosition, true);
        document.removeEventListener('wheel', this._scrollInteractionHandler, true);
        document.removeEventListener('mousewheel', this._scrollInteractionHandler, true);
        document.removeEventListener('DOMMouseScroll', this._scrollInteractionHandler, true);
        document.removeEventListener('touchmove', this._scrollInteractionHandler, true);
        document.removeEventListener('keydown', this._scrollInteractionHandler, true);
      },

      /**
       * Memoizes the scroll position of the outside scrolling element.
       * @private
       */
      _saveScrollPosition: function() {
        if (document.scrollingElement) {
          this._scrollTop = document.scrollingElement.scrollTop;
          this._scrollLeft = document.scrollingElement.scrollLeft;
        } else {
          // Since we don't know if is the body or html, get max.
          this._scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop);
          this._scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);
        }
      },

      /**
       * Resets the scroll position of the outside scrolling element.
       * @private
       */
      _restoreScrollPosition: function() {
        if (document.scrollingElement) {
          document.scrollingElement.scrollTop = this._scrollTop;
          document.scrollingElement.scrollLeft = this._scrollLeft;
        } else {
          // Since we don't know if is the body or html, set both.
          document.documentElement.scrollTop = this._scrollTop;
          document.documentElement.scrollLeft = this._scrollLeft;
          document.body.scrollTop = this._scrollTop;
          document.body.scrollLeft = this._scrollLeft;
        }
      }
    };
  })();

</script>
