<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">

<script>
  (function() {
    'use strict';
    // Used to calculate the scroll direction.
    var PREVIOUS_TOUCH = {
      pageX: 0,
      pageY: 0
    };
    // Memoize target and scrollable nodes for better perf.
    var PREVIOUS_TARGET = null;
    var SCROLLABLE_NODES = [];

    /**
     * The IronDropdownScrollManager is intended to provide a central source
     * of authority and control over which elements in a document are currently
     * allowed to scroll.
     */

    Polymer.IronDropdownScrollManager = {

      /**
       * The current element that defines the DOM boundaries of the
       * scroll lock. This is always the most recently locking element.
       */
      get currentLockingElement() {
        return this._lockingElements[this._lockingElements.length - 1];
      },

      /**
       * Returns true if the provided element is "scroll locked", which is to
       * say that it cannot be scrolled via pointer or keyboard interactions.
       *
       * @param {HTMLElement} element An HTML element instance which may or may
       * not be scroll locked.
       */
      elementIsScrollLocked: function(element) {
        var currentLockingElement = this.currentLockingElement;

        if (currentLockingElement === undefined)
          return false;

        var scrollLocked;

        if (this._hasCachedLockedElement(element)) {
          return true;
        }

        if (this._hasCachedUnlockedElement(element)) {
          return false;
        }

        scrollLocked = !!currentLockingElement &&
          currentLockingElement !== element &&
          !Polymer.dom(currentLockingElement).deepContains(element);

        if (scrollLocked) {
          this._lockedElementCache.push(element);
        } else {
          this._unlockedElementCache.push(element);
        }

        return scrollLocked;
      },

      /**
       * Push an element onto the current scroll lock stack. The most recently
       * pushed element and its children will be considered scrollable. All
       * other elements will not be scrollable.
       *
       * Scroll locking is implemented as a stack so that cases such as
       * dropdowns within dropdowns are handled well.
       *
       * @param {HTMLElement} element The element that should lock scroll.
       */
      pushScrollLock: function(element) {
        // Prevent pushing the same element twice
        if (this._lockingElements.indexOf(element) >= 0) {
          return;
        }

        if (this._lockingElements.length === 0) {
          this._lockScrollInteractions();
        }

        this._lockingElements.push(element);

        this._lockedElementCache = [];
        this._unlockedElementCache = [];
      },

      /**
       * Remove an element from the scroll lock stack. The element being
       * removed does not need to be the most recently pushed element. However,
       * the scroll lock constraints only change when the most recently pushed
       * element is removed.
       *
       * @param {HTMLElement} element The element to remove from the scroll
       * lock stack.
       */
      removeScrollLock: function(element) {
        var index = this._lockingElements.indexOf(element);

        if (index === -1) {
          return;
        }

        this._lockingElements.splice(index, 1);

        this._lockedElementCache = [];
        this._unlockedElementCache = [];

        if (this._lockingElements.length === 0) {
          this._unlockScrollInteractions();
        }

      },

      _lockingElements: [],

      _lockedElementCache: null,

      _unlockedElementCache: null,

      _isScrollingKeypress: function(event) {
        return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(
          event, 'pageup pagedown home end up left down right');
      },

      _hasCachedLockedElement: function(element) {
        return this._lockedElementCache.indexOf(element) > -1;
      },

      _hasCachedUnlockedElement: function(element) {
        return this._unlockedElementCache.indexOf(element) > -1;
      },

      _scrollInteractionHandler: function(event) {
        if (this._shouldPreventScrolling(event)) {
          event.preventDefault();
        }
        var touch = this._getTouchFromEvent(event);
        PREVIOUS_TOUCH.pageX = touch.pageX;
        PREVIOUS_TOUCH.pageY = touch.pageY;
      },

      _lockScrollInteractions: function() {
        this._boundScrollHandler = this._boundScrollHandler ||
          this._scrollInteractionHandler.bind(this);
        // Modern `wheel` event for mouse wheel scrolling:
        document.addEventListener('wheel', this._boundScrollHandler, true);
        // Older, non-standard `mousewheel` event for some FF:
        document.addEventListener('mousewheel', this._boundScrollHandler, true);
        // IE:
        document.addEventListener('DOMMouseScroll', this._boundScrollHandler, true);
        // Save the SCROLLABLE_NODES on touchstart, to be used on touchmove.
        document.addEventListener('touchstart', this._boundScrollHandler, true);
        // Mobile devices can scroll on touch move:
        document.addEventListener('touchmove', this._boundScrollHandler, true);
        // Capture keydown to prevent scrolling keys (pageup, pagedown etc.)
        document.addEventListener('keydown', this._boundScrollHandler, true);
      },

      _unlockScrollInteractions: function() {
        document.removeEventListener('wheel', this._boundScrollHandler, true);
        document.removeEventListener('mousewheel', this._boundScrollHandler, true);
        document.removeEventListener('DOMMouseScroll', this._boundScrollHandler, true);
        document.removeEventListener('touchstart', this._boundScrollHandler, true);
        document.removeEventListener('touchmove', this._boundScrollHandler, true);
        document.removeEventListener('keydown', this._boundScrollHandler, true);
      },

      _getTouchFromEvent: function(event) {
        return event.targetTouches ? event.targetTouches[0] : event;
      },

      /**
       * Returns true if the event causes scroll outside the current locking
       * element, e.g. pointer or keyboard interactions, or scroll "leaking"
       * outside the locking element when it is already at its scroll boundaries.
       *
       * @param {!Event} event The scroll event
       * @return {boolean}
       * @private
       */
      _shouldPreventScrolling: function(event) {
        // Avoid expensive checks if the event is not one of the observed keys.
        if (event.type === 'keydown') {
          // Prevent event if it is one of the scrolling keys.
          return this._isScrollingKeypress(event);
        }

        // Update if root target changed. For touch events, ensure we don't
        // update during touchmove.
        var target = Polymer.dom(event).rootTarget;
        if (event.type !== 'touchmove' && PREVIOUS_TARGET !== target) {
          PREVIOUS_TARGET = target;
          SCROLLABLE_NODES = this._getScrollableNodes(Polymer.dom(event).path);
        }

        // Prevent event if no scrollable nodes.
        if (!SCROLLABLE_NODES.length) {
          return true;
        }
        // Don't prevent touchstart events inside the locking element.
        if (event.type === 'touchstart') {
          return false;
        }

        // Get deltaX/Y.
        var info = this._getScrollInfo(event);
        // Prevent if there is no child that can scroll.
        return !this._getScrollingNode(SCROLLABLE_NODES, info.vertical, info.delta);
      },

      /**
       * Returns an array of scrollable nodes up to currentLockingElement.
       * @param {!Array<Node>} nodes
       * @return {Array<Node>} scrollables
       * @private
       */
      _getScrollableNodes: function(nodes) {
        var scrollables = [];
        var lockingIndex = nodes.indexOf(this.currentLockingElement);
        for (var i = 0; i <= lockingIndex; i++) {
          var node = nodes[i];
          // Skip document fragments.
          if (node.nodeType === 11) {
            continue;
          }
          // Check inline style before checking computed style.
          var style = node.style;
          if (style.overflow !== 'scroll' && style.overflow !== 'auto') {
            style = window.getComputedStyle(node);
          }
          if (style.overflow === 'scroll' || style.overflow === 'auto') {
            scrollables.push(node);
          }

        }
        return scrollables;
      },

      /**
       * Returns the node that is scrolling.
       * @param {!Array<Node>} nodes
       * @param {boolean} verticalScroll True if scrollDelta is applied vertically.
       * @param {number} scrollDelta Negative value means scroll up/left,
       *  positive value means down/right.
       * @return {Node|undefined}
       * @private
       */
      _getScrollingNode: function(nodes, verticalScroll, scrollDelta) {
        // Loop from root target to locking element (included).
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var canScroll = false;
          if (verticalScroll) {
            // delta < 0 = scroll up, else scroll down.
            canScroll = scrollDelta < 0 ? node.scrollTop > 0 :
              node.scrollTop < node.scrollHeight - node.clientHeight;
          } else {
            // delta < 0 = scroll left, else scroll right.
            canScroll = scrollDelta < 0 ? node.scrollLeft > 0 :
              node.scrollLeft < node.scrollWidth - node.clientWidth;
          }
          if (canScroll) {
            return node;
          }
        }
      },

      /**
       * Returns scroll info like `deltaX` `deltaY` of the event normalized
       * cross-browsers, `delta` and `vertical`.
       *
       * Positive value: scroll down/right
       * Negative value: scroll up/left.
       * @param {!Event} event The scroll event
       * @return {{
       *  deltaX:   number Scroll delta on the x-axis,
       *  deltaY:   number Scroll delta on the y-axis,
       *  delta:    number Dominant scroll delta (see `vertical`),
       *  vertical: boolean If the vertical axis is scrolling more than the
       *            horizontal axis}} info
       * @private
       */
      _getScrollInfo: function(event) {
        var info = {
          deltaX: event.deltaX,
          deltaY: event.deltaY
        };
        // Already available.
        if (event.deltaX || event.deltaY) {
          // do nothing, values are already good.
        }
        // Safari has scroll info in `wheelDeltaX/Y`.
        else if (event.wheelDeltaX || event.wheelDeltaY) {
          info.deltaX = -event.wheelDeltaX;
          info.deltaY = -event.wheelDeltaY;
        }
        // Firefox has scroll info in `detail` and `axis`.
        else if (event.axis) {
          info.deltaX = event.axis === 1 ? event.detail : 0;
          info.deltaY = event.axis === 2 ? event.detail : 0;
        }
        // On mobile devices, calculate scroll direction.
        else {
          var touch = this._getTouchFromEvent(event);
          info.deltaX = touch.pageX - PREVIOUS_TOUCH.pageX;
          info.deltaY = PREVIOUS_TOUCH.pageY - touch.pageY;
        }
        // vertical or horizontal, according to where there is more scroll.
        // Prefer vertical over horizontal.
        info.vertical = Math.abs(info.deltaY) >= Math.abs(info.deltaX);
        info.delta = info.vertical ? info.deltaY : info.deltaX;
        return info;
      }
    };
  })();
</script>
