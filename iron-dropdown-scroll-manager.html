<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">

<script>
  (function() {
    'use strict';

    /**
     * The IronDropdownScrollManager is intended to provide a central source
     * of authority and control over which elements in a document are currently
     * allowed to scroll.
     */

    Polymer.IronDropdownScrollManager = {

      /**
       * The current element that defines the DOM boundaries of the
       * scroll lock. This is always the most recently locking element.
       */
      get currentLockingElement() {
        return this._lockingElements[this._lockingElements.length - 1];
      },


      /**
       * Returns true if the provided element is "scroll locked," which is to
       * say that it cannot be scrolled via pointer or keyboard interactions.
       *
       * @param {HTMLElement} element An HTML element instance which may or may
       * not be scroll locked.
       */
      elementIsScrollLocked: function(element) {
        var currentLockingElement = this.currentLockingElement;

        if (!currentLockingElement || this._hasCachedUnlockedElement(element)) {
          return false;
        }

        if (this._hasCachedLockedElement(element)) {
          return true;
        }

        var scrollLocked = !!currentLockingElement &&
          currentLockingElement !== element &&
          !this._composedTreeContains(currentLockingElement, element);

        if (scrollLocked) {
          this._lockedElementCache.push(element);
        } else {
          this._unlockedElementCache.push(element);
        }

        return scrollLocked;
      },

      /**
       * Push an element onto the current scroll lock stack. The most recently
       * pushed element and its children will be considered scrollable. All
       * other elements will not be scrollable.
       *
       * Scroll locking is implemented as a stack so that cases such as
       * dropdowns within dropdowns are handled well.
       *
       * @param {HTMLElement} element The element that should lock scroll.
       */
      pushScrollLock: function(element) {
        // Prevent pushing the same element twice
        if (this._lockingElements.indexOf(element) >= 0) {
          return;
        }

        if (this._lockingElements.length === 0) {
          this._lockScrollInteractions();
        }

        this._lockingElements.push(element);

        this._lockedElementCache = [];
        this._unlockedElementCache = [];
      },

      /**
       * Remove an element from the scroll lock stack. The element being
       * removed does not need to be the most recently pushed element. However,
       * the scroll lock constraints only change when the most recently pushed
       * element is removed.
       *
       * @param {HTMLElement} element The element to remove from the scroll
       * lock stack.
       */
      removeScrollLock: function(element) {
        var index = this._lockingElements.indexOf(element);

        if (index === -1) {
          return;
        }

        this._lockingElements.splice(index, 1);

        this._lockedElementCache = [];
        this._unlockedElementCache = [];

        if (this._lockingElements.length === 0) {
          this._unlockScrollInteractions();
        }
      },

      _lockingElements: [],

      _lockedElementCache: null,

      _unlockedElementCache: null,

      _scrollingInfo: null,

      _isScrollingKeypress: function(event) {
        return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(
          event, 'pageup pagedown home end up left down right');
      },

      _hasCachedLockedElement: function(element) {
        return this._lockedElementCache.indexOf(element) > -1;
      },

      _hasCachedUnlockedElement: function(element) {
        return this._unlockedElementCache.indexOf(element) > -1;
      },

      _composedTreeContains: function(element, child) {
        // NOTE(cdata): This method iterates over content elements and their
        // corresponding distributed nodes to implement a contains-like method
        // that pierces through the composed tree of the ShadowDOM. Results of
        // this operation are cached (elsewhere) on a per-scroll-lock basis, to
        // guard against potentially expensive lookups happening repeatedly as
        // a user scrolls / touchmoves.
        var contentElements;
        var distributedNodes;
        var contentIndex;
        var nodeIndex;

        if (element.contains(child)) {
          return true;
        }

        contentElements = Polymer.dom(element).querySelectorAll('content');

        for (contentIndex = 0; contentIndex < contentElements.length; ++contentIndex) {

          distributedNodes = Polymer.dom(contentElements[contentIndex]).getDistributedNodes();

          for (nodeIndex = 0; nodeIndex < distributedNodes.length; ++nodeIndex) {

            if (this._composedTreeContains(distributedNodes[nodeIndex], child)) {
              return true;
            }
          }
        }

        return false;
      },

      _scrollInteractionHandler: function(event) {
        var scrolledElement =
            /** @type {HTMLElement} */(Polymer.dom(event).rootTarget);
        if (Polymer
              .IronDropdownScrollManager
              .elementIsScrollLocked(scrolledElement)) {
          if (event.type === 'keydown' &&
              !Polymer.IronDropdownScrollManager._isScrollingKeypress(event)) {
            return;
          }

          event.preventDefault();
        }
      },

      _lockScrollInteractions: function() {
        this._saveScrollInfo();

        // Modern `wheel` event for mouse wheel scrolling:
        document.addEventListener('wheel', this._scrollInteractionHandler, true);
        // Older, non-standard `mousewheel` event for some FF:
        document.addEventListener('mousewheel', this._scrollInteractionHandler, true);
        // IE:
        document.addEventListener('DOMMouseScroll', this._scrollInteractionHandler, true);
        // Mobile devices can scroll on touch move:
        document.addEventListener('touchmove', this._scrollInteractionHandler, true);
        // Capture keydown to prevent scrolling keys (pageup, pagedown etc.)
        document.addEventListener('keydown', this._scrollInteractionHandler, true);
      },

      _unlockScrollInteractions: function() {
        this._restoreScrollInfo();

        document.removeEventListener('wheel', this._scrollInteractionHandler, true);
        document.removeEventListener('mousewheel', this._scrollInteractionHandler, true);
        document.removeEventListener('DOMMouseScroll', this._scrollInteractionHandler, true);
        document.removeEventListener('touchmove', this._scrollInteractionHandler, true);
        document.removeEventListener('keydown', this._scrollInteractionHandler, true);
      },

      _saveScrollInfo: function() {
        var scrollingElement = this._getScrollingElement();
        var scrollTop = scrollingElement.scrollTop;
        var scrollLeft = scrollingElement.scrollLeft;

        // Check if it can scroll horizontally or vertically by changing their
        // scroll position and checking if it gets updated.
        var verticalScroll = scrollTop !== 0 ||
            (scrollingElement.scrollTop = 1) === scrollingElement.scrollTop;
        var horizontalScroll = scrollLeft !== 0 ||
            (scrollingElement.scrollLeft = 1) === scrollingElement.scrollLeft;
        // Restore the original scroll position.
        scrollingElement.scrollTop = scrollTop;
        scrollingElement.scrollLeft = scrollLeft;

        if (horizontalScroll || verticalScroll) {
          var html = document.documentElement;
          var cs = getComputedStyle(html);
          this._scrollingInfo = {
            scrollingElement: scrollingElement,
            scrollTop: scrollTop,
            scrollLeft: scrollLeft,
            htmlInlineStyles: {
              overflowX: html.style.overflowX,
              overflowY: html.style.overflowY,
              position: html.style.position,
              top: html.style.top,
              left: html.style.left,
              width: html.style.width,
              height: html.style.height
            }
          };
          html.style.overflowY = verticalScroll ? 'scroll' : 'visible';
          html.style.overflowX = horizontalScroll ? 'scroll' : 'visible';
          html.style.position = 'fixed';
          html.style.width = '100%';
          html.style.height = '100%';
          html.style.top = (parseFloat(cs.marginTop) - scrollTop) + 'px';
          html.style.left = (parseFloat(cs.marginLeft) - scrollLeft) + 'px';
        } else {
          this._scrollingInfo = null;
        }
      },

      _restoreScrollInfo: function() {
        if (!this._scrollingInfo) {
          return;
        }
        // Restore html inline styles.
        var html = document.documentElement;
        html.style.overflowY = this._scrollingInfo.htmlInlineStyles.overflowY;
        html.style.overflowX = this._scrollingInfo.htmlInlineStyles.overflowX;
        // Force reflow before resetting position.
        html.scrollTop = html.scrollTop;
        html.style.position = this._scrollingInfo.htmlInlineStyles.position;
        html.style.width = this._scrollingInfo.htmlInlineStyles.width;
        html.style.height = this._scrollingInfo.htmlInlineStyles.height;
        html.style.top = this._scrollingInfo.htmlInlineStyles.top;
        html.style.left = this._scrollingInfo.htmlInlineStyles.left;

        // Restore scroll position to scrolling element.
        var scrollingElement = this._scrollingInfo.scrollingElement;
        scrollingElement.scrollTop = this._scrollingInfo.scrollTop;
        scrollingElement.scrollLeft = this._scrollingInfo.scrollLeft;

        this._scrollingInfo = null;
      },

      _getScrollingElement: function() {
        if (document.scrollingElement) {
          return document.scrollingElement;
        }
        var html = document.documentElement;
        if (html.scrollHeight > html.clientHeight ||
          html.scrollWidth > html.clientWidth) {
          return html;
        }
        return document.body;
      }
    };
  })();
</script>
